/**
 * Credit System Integration with Existing Social Safety System
 * 
 * This module provides hooks and integration points to connect the credit system
 * with existing social safety components like issue reporting, support requests,
 * meeting coordination, and trust/voting systems.
 */

import { EarnCreditRequest, SpendCreditRequest, EscalationRequest } from '../api/credit_endpoints.js';

// ============================================================================
// Integration with Issue Reporting System
// ============================================================================

/**
 * Hook: When someone helps with an issue, earn credits
 * Triggered from: social/api/issue_endpoints.ts when issue status changes to 'resolved'
 */
export async function onIssueResolved(event: {
  issue_id: string;
  reporter: string;
  subject_set: string[];
  helpers: string[];
  resolution_type: 'support' | 'mediation' | 'repair';
  evidence_url?: string;
  timestamp: number;
}) {
  const credit_requests: EarnCreditRequest[] = [];
  
  // Award credits to each helper based on resolution type
  for (const helper of event.helpers) {
    const base_award = getIssueResolutionAward(event.resolution_type);
    
    const earn_request: EarnCreditRequest = {
      requester: helper, // Helper requests credits for their own work
      helper: helper,
      action: {
        type: `issue_${event.resolution_type}`,
        base_award: base_award,
        description: `Helped resolve ${event.resolution_type} issue ${event.issue_id}`
      },
      subject_set: event.subject_set,
      evidence_confidence: event.evidence_url ? 0.9 : 0.7,
      diversity_factor: calculateSubjectDiversity(event.subject_set),
      witnesses: [event.reporter], // Reporter as witness
      evidence_commitments: event.evidence_url ? [event.evidence_url] : undefined,
      timestamp: event.timestamp,
      signature: '' // Would be generated by helper's client
    };
    
    credit_requests.push(earn_request);
  }
  
  return {
    credit_requests,
    integration_type: 'issue_resolution',
    original_event: event
  };
}

/**
 * Hook: When an issue needs escalation beyond local branch capacity
 * Triggered from: social/api/issue_endpoints.ts when issue escalation is requested
 */
export async function onIssueEscalationNeeded(event: {
  issue_id: string;
  requesting_branch: string;
  escalation_reason: string;
  proposed_resolution_tasks: string[];
  timebox_hours: number;
  timestamp: number;
}) {
  const escalation_request: EscalationRequest = {
    requester: '', // Would be set by branch representative
    issue_id: event.issue_id,
    requesting_branch: event.requesting_branch,
    proposed_tasks: event.proposed_resolution_tasks,
    timebox_hours: event.timebox_hours,
    timestamp: event.timestamp,
    signature: '' // Would be generated
  };
  
  return {
    escalation_request,
    integration_type: 'issue_escalation',
    original_event: event
  };
}

// ============================================================================
// Integration with Support Request System
// ============================================================================

/**
 * Hook: When someone provides support, earn credits
 * Triggered from: social/api/support_endpoints.ts when support is marked complete
 */
export async function onSupportProvided(event: {
  support_id: string;
  requester: string;
  supporters: string[];
  support_type: 'emotional' | 'technical' | 'resource' | 'advocacy';
  outcome_rating: number; // 1-5 scale from requester
  completion_timestamp: number;
}) {
  const credit_requests: EarnCreditRequest[] = [];
  
  // Award credits to each supporter
  for (const supporter of event.supporters) {
    const base_award = getSupportTypeAward(event.support_type);
    
    // Outcome quality affects evidence confidence
    const evidence_confidence = Math.max(0.3, event.outcome_rating / 5);
    
    const earn_request: EarnCreditRequest = {
      requester: supporter,
      helper: supporter,
      action: {
        type: `support_${event.support_type}`,
        base_award: base_award,
        description: `Provided ${event.support_type} support for ${event.support_id}`
      },
      subject_set: [event.requester],
      evidence_confidence: evidence_confidence,
      diversity_factor: 1.0, // Single person helped
      witnesses: [event.requester],
      timestamp: event.completion_timestamp,
      signature: ''
    };
    
    credit_requests.push(earn_request);
  }
  
  return {
    credit_requests,
    integration_type: 'support_provision',
    original_event: event
  };
}

/**
 * Hook: When someone requests support that requires credits to fund
 * Triggered from: social/api/support_endpoints.ts when high-effort support is requested
 */
export async function onSupportRequestNeedsFunding(event: {
  support_id: string;
  requester: string;
  support_type: 'technical' | 'resource' | 'advocacy';
  estimated_effort_hours: number;
  requesting_branch: string;
  timestamp: number;
}) {
  // Calculate credit cost based on effort estimate
  const cost_per_hour = 2; // Credits per hour of effort
  const funding_amount = Math.min(20, event.estimated_effort_hours * cost_per_hour);
  
  const spend_request: SpendCreditRequest = {
    requester: event.requester,
    spend_type: 'local',
    amount: funding_amount,
    purpose: `Fund ${event.support_type} support request ${event.support_id}`,
    branch_votes: [], // Would be populated by branch voting
    timestamp: event.timestamp,
    signature: ''
  };
  
  return {
    spend_request,
    integration_type: 'support_funding',
    original_event: event
  };
}

// ============================================================================
// Integration with Meeting Coordination System  
// ============================================================================

/**
 * Hook: When someone organizes or facilitates meetings, earn credits
 * Triggered from: social/api/meeting_endpoints.ts when meeting concludes
 */
export async function onMeetingCompleted(event: {
  meeting_id: string;
  organizers: string[];
  facilitators: string[];
  participants: string[];
  meeting_type: 'community' | 'support' | 'decision' | 'repair';
  duration_minutes: number;
  outcome_rating: number; // Average participant rating
  timestamp: number;
}) {
  const credit_requests: EarnCreditRequest[] = [];
  
  // Award credits to organizers and facilitators
  const roles = [
    { people: event.organizers, role: 'organization' },
    { people: event.facilitators, role: 'facilitation' }
  ];
  
  for (const { people, role } of roles) {
    for (const person of people) {
      const base_award = getMeetingRoleAward(role, event.meeting_type);
      
      // Scale award by duration and outcome quality
      const duration_factor = Math.min(2.0, event.duration_minutes / 60); // Max 2x for long meetings
      const quality_factor = Math.max(0.5, event.outcome_rating / 5);
      
      const earn_request: EarnCreditRequest = {
        requester: person,
        helper: person,
        action: {
          type: `meeting_${role}`,
          base_award: Math.round(base_award * duration_factor * quality_factor),
          description: `${role} for ${event.meeting_type} meeting ${event.meeting_id}`
        },
        subject_set: event.participants,
        evidence_confidence: 0.8, // Meeting attendance is verifiable
        diversity_factor: calculateSubjectDiversity(event.participants),
        witnesses: event.participants.slice(0, 3), // First 3 participants as witnesses
        timestamp: event.timestamp,
        signature: ''
      };
      
      credit_requests.push(earn_request);
    }
  }
  
  return {
    credit_requests,
    integration_type: 'meeting_coordination',
    original_event: event
  };
}

// ============================================================================
// Integration with Trust and Voting System
// ============================================================================

/**
 * Hook: When someone participates in voting processes, earn small credits
 * Triggered from: social/api/voting_endpoints.ts when votes are cast
 */
export async function onVotingParticipation(event: {
  vote_id: string;
  voters: string[];
  vote_type: 'consensus' | 'priority' | 'resource_allocation';
  branch_id: string;
  timestamp: number;
}) {
  const credit_requests: EarnCreditRequest[] = [];
  
  // Small reward for democratic participation
  const base_award = 1; // Small amount for civic engagement
  
  for (const voter of event.voters) {
    const earn_request: EarnCreditRequest = {
      requester: voter,
      helper: voter,
      action: {
        type: 'democratic_participation',
        base_award: base_award,
        description: `Participated in ${event.vote_type} voting ${event.vote_id}`
      },
      subject_set: [], // Voting benefits the whole community
      evidence_confidence: 1.0, // Voting is cryptographically verified
      diversity_factor: 1.0,
      witnesses: [],
      timestamp: event.timestamp,
      signature: ''
    };
    
    credit_requests.push(earn_request);
  }
  
  return {
    credit_requests,
    integration_type: 'democratic_participation',
    original_event: event
  };
}

// ============================================================================
// Integration with Trust Relationship Updates
// ============================================================================

/**
 * Hook: When trust relationships are updated, small credits for maintenance
 * Triggered from: social/api/trust_endpoints.ts when trust attestations are made
 */
export async function onTrustMaintenance(event: {
  attestor: string;
  target: string;
  trust_level: number;
  evidence_provided: boolean;
  timestamp: number;
}) {
  // Very small reward for maintaining trust network
  const base_award = 0.5;
  
  const earn_request: EarnCreditRequest = {
    requester: event.attestor,
    helper: event.attestor,
    action: {
      type: 'trust_maintenance',
      base_award: base_award,
      description: `Updated trust attestation for ${event.target}`
    },
    subject_set: [event.target],
    evidence_confidence: event.evidence_provided ? 0.8 : 0.5,
    diversity_factor: 1.0,
    witnesses: [],
    timestamp: event.timestamp,
    signature: ''
  };
  
  return {
    credit_request: earn_request,
    integration_type: 'trust_maintenance',
    original_event: event
  };
}

// ============================================================================
// Helper Functions for Award Calculation
// ============================================================================

function getIssueResolutionAward(resolution_type: string): number {
  const awards = {
    support: 3,      // Basic support provision
    mediation: 8,    // More complex mediation work
    repair: 12       // Most complex repair work
  };
  return awards[resolution_type] || 3;
}

function getSupportTypeAward(support_type: string): number {
  const awards = {
    emotional: 4,    // Emotional support
    technical: 6,    // Technical help
    resource: 5,     // Resource sharing
    advocacy: 7      // Advocacy work
  };
  return awards[support_type] || 4;
}

function getMeetingRoleAward(role: string, meeting_type: string): number {
  const base_awards = {
    organization: 4,
    facilitation: 6
  };
  
  const type_multipliers = {
    community: 1.0,
    support: 1.2,
    decision: 1.3,
    repair: 1.5
  };
  
  const base = base_awards[role] || 4;
  const multiplier = type_multipliers[meeting_type] || 1.0;
  
  return Math.round(base * multiplier);
}

function calculateSubjectDiversity(subject_set: string[]): number {
  // Simple diversity calculation based on set size
  // Real implementation would consider social network diversity
  if (subject_set.length <= 1) return 1.0;
  if (subject_set.length <= 3) return 1.2;
  if (subject_set.length <= 6) return 1.4;
  return 1.6; // Max diversity bonus
}

// ============================================================================
// Integration Registry
// ============================================================================

/**
 * Registry of all credit system integration points
 * Used by the main social system to trigger credit events
 */
export const CreditIntegrationHooks = {
  // Issue system hooks
  'issue.resolved': onIssueResolved,
  'issue.escalation_needed': onIssueEscalationNeeded,
  
  // Support system hooks  
  'support.provided': onSupportProvided,
  'support.funding_needed': onSupportRequestNeedsFunding,
  
  // Meeting system hooks
  'meeting.completed': onMeetingCompleted,
  
  // Trust/voting system hooks
  'voting.participation': onVotingParticipation,
  'trust.updated': onTrustMaintenance,
};

/**
 * Main integration function called by social system events
 */
export async function triggerCreditIntegration(
  event_type: string, 
  event_data: any
): Promise<{
  credit_requests?: EarnCreditRequest[];
  spend_requests?: SpendCreditRequest[];
  escalation_requests?: EscalationRequest[];
  integration_type: string;
}> {
  const hook = CreditIntegrationHooks[event_type];
  
  if (!hook) {
    return {
      integration_type: 'no_integration',
    };
  }
  
  try {
    const result = await hook(event_data);
    
    // Normalize response format
    return {
      credit_requests: result.credit_requests || (result.credit_request ? [result.credit_request] : []),
      spend_requests: result.spend_request ? [result.spend_request] : [],
      escalation_requests: result.escalation_request ? [result.escalation_request] : [],
      integration_type: result.integration_type
    };
    
  } catch (error) {
    console.error(`Credit integration hook failed for ${event_type}:`, error);
    return {
      integration_type: 'integration_error'
    };
  }
}